7.21 GMP 模型为什么要有 P ？
============================

GM 模型是怎样的？
-----------------

在 Go v1.1 之前，实际上 GMP确实是没有 P 的，所有的 M 线程都要从
全局队列中获取 G 来执行任务，为了避免冲突，从全局队列中获取 G
的时候，要先获取一把大锁。

当一个程序的并发量比较小的时候，影响还不大，而当程序的并发量非常大的时候，这个全局队列会成为性能的瓶颈。

除此之外 ，若直接把 G 从全局队列分配给 M，那么当 G
中当生系统调用或者其他阻塞性的操作时，M
会有一段时间处于挂起的状态，此时又没有新创建线程的线程来代替该线程继续从队列中取出其他
G 来运行，从效率上其实会打折扣。

P 带来的改变
------------

加了 P 之后会带来什么改变呢？

-  每个 P
   有自己的本地队列，大幅度的减轻了对全局队列的直接依赖，所带来的效果就是锁竞争的减少。而
   GM 模型的性能开销大头就是锁竞争。
-  当一个 M 中 运行的 G 发生阻塞性操作时，P 会重新选择一个 M，若没有 M
   就新创建一个 M 来继续从 P 本地队列中取 G 来执行，提高运行效率。
-  每个 P 相对的平衡上，在 GMP 模型中也实现了 Work Stealing 算法，如果 P
   的本地队列为空，则会从全局队列或其他 P 的本地队列中窃取可运行的 G
   来运行，减少空转，提高了资源利用率。
